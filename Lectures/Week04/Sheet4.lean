import Mathlib.Tactic -- imports all of the tactics in Lean's maths library

set_option autoImplicit false
set_option tactic.hygienic false


@[simp,grind] def Nat.MinOfList (a :ℕ ) (t: List ℕ) : Prop := ∀ y ∈ t, a ≤ y

-- Let's discuss in English
-- How do define inductively of sortedness

-- inductive predicate
inductive Sorted: List ℕ  → Prop
  | nil : Sorted []
  | single (a : ℕ) : Sorted [a]
  | cons (a b : ℕ ) (t : List ℕ ) : a ≤ b → Sorted (b :: t) → Sorted (a :: b :: t)
  | cons_min (a :ℕ) (t : List ℕ) : a.MinOfList t → Sorted (t) →  Sorted (a :: t)

#check Sorted.single
#check Sorted.nil

-- # Example
example: Sorted [1] := by
  exact Sorted.single 1

#check Sorted.cons

-- # Example
example: Sorted [1,2,3] := by
  apply Sorted.cons
  omega
  apply Sorted.cons
  omega
  exact Sorted.single 3

/-!  New Tactics for inductive type
  cases -- For every element of inductive type, imagine the last step it was generated by a constructor.
        -- Intuitively, `cases` tactic allows us to prove that for every constructor that an element can be produced, the goal can be proved.
        -- Any additional assumptions may be given from the constructor.
-/

-- # Example
example: ¬ Sorted [20,3,1] := by
  by_contra!
  cases this
  omega
  aesop

-- # Example
example: ¬ Sorted [1,3,2] := by
  by_contra!
  cases this
  · cases a_2
    omega
    aesop
  · cases a_2
    omega
    aesop

-- # Example
#check Sorted
theorem sorted_min {x : ℕ} {xs : List ℕ} (hxs : Sorted (x :: xs)) :  x.MinOfList xs  := by
  cases hxs
  · simp
  · simp
    refine ⟨a_1,?_⟩
    apply sorted_min at a_2
    grind
  · exact fun y a ↦ a_1 y a

-- # Exercise 4.1
theorem sorted_suffix {x : ℕ} {xs : List ℕ} (hxs : Sorted (x :: xs)) : Sorted xs := sorry

-- # Exercise 4.2
theorem sorted_is_preserved_by_min_cons {a : ℕ} {t : List ℕ} (hmin : a.MinOfList t) (ht : Sorted t) :
  Sorted (a :: t) := by sorry

-- # Exercise 4.3
theorem sorted_head_of_tail_min {x y : ℕ} {t : List ℕ} (hsort : Sorted (x :: y :: t)) :
y.MinOfList t := by sorry

-- # Exercise 4.4
theorem list_len_le_one_sorted : ∀ (l : List ℕ), List.length l ≤ 1 → Sorted l := by sorry
